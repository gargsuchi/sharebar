<?php

namespace Drupal\drupalmoduleupgrader\Converter\Routing;

use Drupal\drupalmoduleupgrader\Converter\ConverterBase;
use Drupal\drupalmoduleupgrader\Converter\Routing\Drupal7\ParameterMap;
use Drupal\drupalmoduleupgrader\Converter\Routing\Drupal7\RouteWrapper as Drupal7Route;
use Drupal\drupalmoduleupgrader\Converter\Routing\Drupal8\RouteWrapper as Drupal8Route;
use Drupal\drupalmoduleupgrader\TargetInterface;
use Drupal\drupalmoduleupgrader\Utility\StringTransformTrait;
use Pharborist\ClassMethodCallNode;
use Pharborist\ClassNode;
use Pharborist\Filter;
use Pharborist\Functions\FunctionDeclarationNode;
use Pharborist\Functions\ParameterNode;
use Pharborist\ReturnStatementNode;
use Drupal\Core\Routing\RouteProviderInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\Routing\Route as CoreRoute;

/**
 * Base class for route converters, which are usually delegates of
 * \Drupal\drupalmoduleupgrader\Plugin\DMU\ModuleWide\HookMenu.
 */
abstract class RouteConverterBase extends ConverterBase implements RouteConverterInterface {

  use StringTransformTrait;

  /**
   * The controller into which callback functions are transferred.
   *
   * @var \Pharborist\ClassNode
   */
  protected $controller;

  /**
   * @var \Drupal\drupalmoduleupgrader\Converter\Routing\Drupal7\RouteWrapper
   */
  protected $route;

  /**
   * @var \Drupal\Core\Routing\RouteProviderInterface
   */
  protected $routeProvider;

  /**
   * Constructs a RouteConverterBase object.
   */
  public function __construct(array $configuration, $plugin_id, $plugin_definition, RouteProviderInterface $route_provider) {
    parent::__construct($configuration, $plugin_id, $plugin_definition);
    $this->route = clone $configuration['route'];
    $this->arguments = $this->route['page arguments'];
    $this->routeProvider = $route_provider;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static($configuration, $plugin_id, $plugin_definition, $container->get('router.route_provider'));
  }

  /**
   * {@inheritdoc}
   */
  public function buildPath() {
    $path = clone $this->route->getPath();
    $this->buildParameterMap()->applyPath($path);
    return $path;
  }

  /**
   * Builds a parameter map from the aggregated arguments of the title,
   * access, and page callbacks.
   *
   * @return \Drupal\drupalmoduleupgrader\Converter\Routing\Drupal7\ParameterMap
   */
  protected function buildParameterMap() {
    $map = new ParameterMap(clone $this->route->getPath(), []);

    if ($this->route['title arguments'] instanceof ParameterMap) {
      $map->merge($this->route['title arguments']);
    }
    if ($this->route['access arguments'] instanceof ParameterMap) {
      $map->merge($this->route['access arguments']);
    }
    if ($this->route['page arguments'] instanceof ParameterMap) {
      $map->merge($this->route['page arguments']);
    }

    return $map;
  }

  /**
   * {@inheritdoc}
   */
  public function buildRouteDefinition(TargetInterface $target, Drupal7Route $route) {
    $indexer = $target->getIndexer();

    $definition = new CoreRoute('');
    $this->buildParameterMap($definition)->applyRoute($definition);

    if ($route->containsKey('title')) {
      $definition->setDefault('_title', $this->route['title']);
    }
    elseif ($indexer->has('function', $route['title callback'])) {
      $definition->setDefault('_title_callback', $this->getController($target)->getName()->getAbsolutePath() . '::' . $route['title callback']);
    }

    if ($route->isAbsoluteAccess()) {
      $definition->setRequirement('_access', $route['access callback'] ? 'true' : 'false');
    }
    elseif ($route->isPermissionBased()) {
      $definition->setRequirement('_permission', $route['access arguments'][0]);
    }
    elseif ($indexer->has('function', $route['access callback'])) {
      $definition->setRequirement('_custom_access', $this->getController($target)->getName()->getAbsolutePath() . '::' . $route['access callback']);
    }

    return $definition;
  }

  /**
   * {@inheritdoc}
   */
  public function buildRoute(TargetInterface $target, Drupal7Route $route) {
    $definition = $this->buildRouteDefinition($target, $route);

    $map = $this->buildParameterMap($definition);
    $map->applyRoute($definition);
    $map->finalize();

    return new Drupal8Route($this->getName($target, $route), $definition, $this->routeProvider);
  }

  public function init(TargetInterface $target) {
    $indexer = $target->getIndexer();

    // Use the default controller generated by HookMenu. Subclasses can
    // swap in their own controller, if need be (i.e., FormRoute).
    $this->controller = $this->getController($target);

    $title_callback = $this->route['title callback'];
    if ($indexer->has('function', $title_callback)) {
      $this->route['title callback'] = clone $indexer->get('function', $title_callback)->get(0);
      $this->route['title arguments'] = new ParameterMap($this->route->getPath(), $this->route['title callback']->getParameters(), $this->route['title arguments']);
    }

    $access_callback = $this->route['access callback'];
    if ($indexer->has('function', $access_callback)) {
      $this->route['access callback'] = clone $indexer->get('function', $access_callback)->get(0);
      $this->route['access arguments'] = new ParameterMap($this->route->getPath(), $this->route['access callback']->getParameters(), $this->route['access arguments']);
    }

    $page_callback = $this->route['page callback'];
    if ($indexer->has('function', $page_callback)) {
      $this->route['page callback'] = clone $indexer->get('function', $page_callback)->get(0);
      $this->route['page arguments'] = new ParameterMap($this->route->getPath(), $this->route['page callback']->getParameters(), $this->route['page arguments']);
    }
  }

  /**
   * {@inheritdoc}
   */
  public function convert(TargetInterface $target, Drupal7Route $route) {
    $this->controller = $this->getController($target);

    if ($this->route['title callback'] instanceof FunctionDeclarationNode) {
      $this->transferToController($this->route['title callback']);
    }
    if ($this->route['access callback'] instanceof FunctionDeclarationNode) {
      $returns = $this->route['access callback']->find(Filter::isInstanceOf('\Pharborist\ReturnStatementNode'));
      foreach ($returns as $ret) {
        $call = ClassMethodCallNode::create('\Drupal\Core\Access\AccessResult', 'allowedIf')->appendArgument($ret->getExpression());
        $ret->replaceWith(ReturnStatementNode::create($call));
      }

      // The access callback always receives an $account parameter.
      if ($this->route['access callback']->hasParameter('account')) {
        $this->route['access callback']->getParameter('account')->setTypeHint('Drupal\Core\Session\AccountInterface');
      }
      else {
        $account = ParameterNode::create('account')->setTypeHint('Drupal\Core\Session\AccountInterface');
        $this->route['access callback']->appendParameter($account);
      }

      $this->transferToController($this->route['access callback']);
    }
  }

  protected function getController(TargetInterface $target) {
    if (empty($this->controller)) {
      // Create the default controller.
      $render = [
        '#theme' => 'dmu_controller',
        '#module' => $target->id(),
      ];
      $this->controller = $this->parse($render);
    }
    return $this->controller;
  }

  /**
   * Transfers a function into the controller, if it hasn't already been.
   *
   * @param \Pharborist\Functions\FunctionDeclarationNode $function
   *  The function to transfer.
   *
   * @return mixed
   *  The fully qualified method name.
   */
  protected function transferToController(FunctionDeclarationNode $function) {
    $function_name = $function->getName()->__toString();

    if (! in_array($function_name, static::$processed)) {
      static::$processed[] = $function_name;

      $function
        ->cloneAsMethodOf($this->controller)
        ->setName($function_name);
    }

    return $this->getQualifiedMethodName($this->controller, $function_name);
  }

  /**
   * Converts a string to a fully qualified method name in the controller.
   *
   * @param string $string
   *  The string to convert (usually a function name).
   *
   * @return string
   */
  protected function getQualifiedMethodName(ClassNode $class, $string) {
    return $class->getName()->getAbsolutePath() . '::' . $string;
  }

}
